"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(rsc)/./node_modules/@vercel/blob/dist/chunk-KN6WT5GP.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/chunk-KN6WT5GP.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* binding */ BlobAccessError),\n/* harmony export */   BlobClientTokenExpiredError: () => (/* binding */ BlobClientTokenExpiredError),\n/* harmony export */   BlobContentTypeNotAllowedError: () => (/* binding */ BlobContentTypeNotAllowedError),\n/* harmony export */   BlobError: () => (/* binding */ BlobError),\n/* harmony export */   BlobFileTooLargeError: () => (/* binding */ BlobFileTooLargeError),\n/* harmony export */   BlobNotFoundError: () => (/* binding */ BlobNotFoundError),\n/* harmony export */   BlobPathnameMismatchError: () => (/* binding */ BlobPathnameMismatchError),\n/* harmony export */   BlobRequestAbortedError: () => (/* binding */ BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* binding */ BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* binding */ BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* binding */ BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* binding */ BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* binding */ BlobUnknownError),\n/* harmony export */   MAXIMUM_PATHNAME_LENGTH: () => (/* binding */ MAXIMUM_PATHNAME_LENGTH),\n/* harmony export */   createCompleteMultipartUploadMethod: () => (/* binding */ createCompleteMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploadMethod: () => (/* binding */ createCreateMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploaderMethod: () => (/* binding */ createCreateMultipartUploaderMethod),\n/* harmony export */   createFolder: () => (/* binding */ createFolder),\n/* harmony export */   createPutMethod: () => (/* binding */ createPutMethod),\n/* harmony export */   createUploadPartMethod: () => (/* binding */ createUploadPartMethod),\n/* harmony export */   disallowedPathnameCharacters: () => (/* binding */ disallowedPathnameCharacters),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getTokenFromOptionsOrEnv: () => (/* binding */ getTokenFromOptionsOrEnv),\n/* harmony export */   requestApi: () => (/* binding */ requestApi)\n/* harmony export */ });\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-node-process */ \"(rsc)/./node_modules/is-node-process/lib/index.mjs\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-buffer */ \"(rsc)/./node_modules/is-buffer/index.js\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! async-retry */ \"(rsc)/./node_modules/async-retry/lib/index.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/undici/index.js\");\n/* harmony import */ var bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bytes */ \"(rsc)/./node_modules/bytes/index.js\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! throttleit */ \"(rsc)/./node_modules/throttleit/index.js\");\n// src/helpers.ts\n\n\n// src/multipart/helpers.ts\n\n\nvar supportsNewBlobFromArrayBuffer = new Promise((resolve) => {\n  try {\n    const helloAsArrayBuffer = new Uint8Array([104, 101, 108, 108, 111]);\n    const blob = new Blob([helloAsArrayBuffer]);\n    blob.text().then((text) => {\n      resolve(text === \"hello\");\n    }).catch(() => {\n      resolve(false);\n    });\n  } catch {\n    resolve(false);\n  }\n});\nasync function toReadableStream(value) {\n  if (value instanceof ReadableStream) {\n    return value;\n  }\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n  if (isNodeJsReadableStream(value)) {\n    return stream__WEBPACK_IMPORTED_MODULE_1__.Readable.toWeb(value);\n  }\n  let streamValue;\n  if (value instanceof ArrayBuffer) {\n    streamValue = new Uint8Array(value);\n  } else if (isNodeJsBuffer(value)) {\n    streamValue = value;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n  if (await supportsNewBlobFromArrayBuffer) {\n    return new Blob([streamValue]).stream();\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    }\n  });\n}\nfunction isNodeJsReadableStream(value) {\n  return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n  typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\nfunction isNodeJsBuffer(value) {\n  return is_buffer__WEBPACK_IMPORTED_MODULE_2__(value);\n}\n\n// src/helpers.ts\nfunction getTokenFromOptionsOrEnv(options) {\n  if (options == null ? void 0 : options.token) {\n    return options.token;\n  }\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n  throw new BlobError(\n    \"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\"\n  );\n}\nvar BlobError = class extends Error {\n  constructor(message) {\n    super(`Vercel Blob: ${message}`);\n  }\n};\nfunction getDownloadUrl(blobUrl) {\n  const url = new URL(blobUrl);\n  url.searchParams.set(\"download\", \"1\");\n  return url.toString();\n}\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\nvar disallowedPathnameCharacters = [\"#\", \"?\", \"//\"];\nvar supportsRequestStreams = (() => {\n  if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_0__.isNodeProcess)()) {\n    return true;\n  }\n  let duplexAccessed = false;\n  const hasContentType = new Request(getApiUrl(), {\n    body: new ReadableStream(),\n    method: \"POST\",\n    // @ts-expect-error -- TypeScript doesn't yet have duplex but it's in the spec: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1729\n    get duplex() {\n      duplexAccessed = true;\n      return \"half\";\n    }\n  }).headers.has(\"Content-Type\");\n  return duplexAccessed && !hasContentType;\n})();\nfunction getApiUrl(pathname = \"\") {\n  let baseUrl = null;\n  try {\n    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n  }\n  return `${baseUrl || \"https://blob.vercel-storage.com\"}${pathname}`;\n}\nvar TEXT_ENCODER = typeof TextEncoder === \"function\" ? new TextEncoder() : null;\nfunction computeBodyLength(body) {\n  if (!body) {\n    return 0;\n  }\n  if (typeof body === \"string\") {\n    if (TEXT_ENCODER) {\n      return TEXT_ENCODER.encode(body).byteLength;\n    }\n    return new Blob([body]).size;\n  }\n  if (\"byteLength\" in body && typeof body.byteLength === \"number\") {\n    return body.byteLength;\n  }\n  if (\"size\" in body && typeof body.size === \"number\") {\n    return body.size;\n  }\n  return 0;\n}\nvar createChunkTransformStream = (chunkSize, onProgress) => {\n  let buffer = new Uint8Array(0);\n  return new TransformStream({\n    transform(chunk, controller) {\n      queueMicrotask(() => {\n        const newBuffer = new Uint8Array(buffer.length + chunk.byteLength);\n        newBuffer.set(buffer);\n        newBuffer.set(new Uint8Array(chunk), buffer.length);\n        buffer = newBuffer;\n        while (buffer.length >= chunkSize) {\n          const newChunk = buffer.slice(0, chunkSize);\n          controller.enqueue(newChunk);\n          onProgress == null ? void 0 : onProgress(newChunk.byteLength);\n          buffer = buffer.slice(chunkSize);\n        }\n      });\n    },\n    flush(controller) {\n      queueMicrotask(() => {\n        if (buffer.length > 0) {\n          controller.enqueue(buffer);\n          onProgress == null ? void 0 : onProgress(buffer.byteLength);\n        }\n      });\n    }\n  });\n};\nfunction isReadableStream(value) {\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Not present in Node.js 16\n    globalThis.ReadableStream && // TODO: Can be removed once Node.js 16 is no more required internally\n    value instanceof ReadableStream\n  );\n}\nfunction isStream(value) {\n  if (isReadableStream(value)) {\n    return true;\n  }\n  if (isNodeJsReadableStream(value)) {\n    return true;\n  }\n  return false;\n}\n\n// src/api.ts\n\n\n// src/is-network-error.ts\nvar objectToString = Object.prototype.toString;\nvar isError = (value) => objectToString.call(value) === \"[object Error]\";\nvar errorMessages = /* @__PURE__ */ new Set([\n  \"network error\",\n  // Chrome\n  \"Failed to fetch\",\n  // Chrome\n  \"NetworkError when attempting to fetch resource.\",\n  // Firefox\n  \"The Internet connection appears to be offline.\",\n  // Safari 16\n  \"Load failed\",\n  // Safari 17+\n  \"Network request failed\",\n  // `cross-fetch`\n  \"fetch failed\",\n  // Undici (Node.js)\n  \"terminated\"\n  // Undici (Node.js)\n]);\nfunction isNetworkError(error) {\n  const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n  if (!isValid) {\n    return false;\n  }\n  if (error.message === \"Load failed\") {\n    return error.stack === void 0;\n  }\n  return errorMessages.has(error.message);\n}\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n    debugIsActive = true;\n  }\n} catch (error) {\n}\nfunction debug(message, ...args) {\n  if (debugIsActive) {\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n\n// src/fetch.ts\n\nvar hasFetch = typeof undici__WEBPACK_IMPORTED_MODULE_4__.fetch === \"function\";\nvar hasFetchWithUploadProgress = hasFetch && supportsRequestStreams;\nvar CHUNK_SIZE = 64 * 1024;\nvar blobFetch = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using fetch\");\n  let body;\n  if (init.body) {\n    if (onUploadProgress) {\n      const stream = await toReadableStream(init.body);\n      let loaded = 0;\n      const chunkTransformStream = createChunkTransformStream(\n        CHUNK_SIZE,\n        (newLoaded) => {\n          loaded += newLoaded;\n          onUploadProgress(loaded);\n        }\n      );\n      body = stream.pipeThrough(chunkTransformStream);\n    } else {\n      body = init.body;\n    }\n  }\n  const duplex = supportsRequestStreams && body && isStream(body) ? \"half\" : void 0;\n  return (0,undici__WEBPACK_IMPORTED_MODULE_4__.fetch)(\n    input,\n    // @ts-expect-error -- Blob and Nodejs Blob are triggering type errors, fine with it\n    {\n      ...init,\n      ...init.body ? { body } : {},\n      duplex\n    }\n  );\n};\n\n// src/xhr.ts\nvar hasXhr = typeof XMLHttpRequest !== \"undefined\";\nvar blobXhr = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using xhr\");\n  let body = null;\n  if (init.body) {\n    if (isReadableStream(init.body)) {\n      body = await new Response(init.body).blob();\n    } else {\n      body = init.body;\n    }\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(init.method || \"GET\", input.toString(), true);\n    if (onUploadProgress) {\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          onUploadProgress(event.loaded);\n        }\n      });\n    }\n    xhr.onload = () => {\n      var _a3;\n      if ((_a3 = init.signal) == null ? void 0 : _a3.aborted) {\n        reject(new DOMException(\"The user aborted the request.\", \"AbortError\"));\n        return;\n      }\n      const headers = new Headers();\n      const rawHeaders = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n      rawHeaders.forEach((line) => {\n        const parts = line.split(\": \");\n        const key = parts.shift();\n        const value = parts.join(\": \");\n        if (key) headers.set(key.toLowerCase(), value);\n      });\n      const response = new Response(xhr.response, {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers\n      });\n      resolve(response);\n    };\n    xhr.onerror = () => {\n      reject(new TypeError(\"Network request failed\"));\n    };\n    xhr.ontimeout = () => {\n      reject(new TypeError(\"Network request timed out\"));\n    };\n    xhr.onabort = () => {\n      reject(new DOMException(\"The user aborted a request.\", \"AbortError\"));\n    };\n    if (init.headers) {\n      const headers = new Headers(init.headers);\n      headers.forEach((value, key) => {\n        xhr.setRequestHeader(key, value);\n      });\n    }\n    if (init.signal) {\n      init.signal.addEventListener(\"abort\", () => {\n        xhr.abort();\n      });\n      if (init.signal.aborted) {\n        xhr.abort();\n        return;\n      }\n    }\n    xhr.send(body);\n  });\n};\n\n// src/request.ts\nvar blobRequest = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  if (onUploadProgress) {\n    if (hasFetchWithUploadProgress) {\n      return blobFetch({ input, init, onUploadProgress });\n    }\n    if (hasXhr) {\n      return blobXhr({ input, init, onUploadProgress });\n    }\n  }\n  if (hasFetch) {\n    return blobFetch({ input, init });\n  }\n  if (hasXhr) {\n    return blobXhr({ input, init });\n  }\n  throw new Error(\"No request implementation available\");\n};\n\n// src/dom-exception.ts\nvar _a2;\nvar DOMException2 = (_a2 = globalThis.DOMException) != null ? _a2 : (() => {\n  try {\n    atob(\"~\");\n  } catch (err) {\n    return Object.getPrototypeOf(err).constructor;\n  }\n})();\n\n// src/api.ts\nvar MAXIMUM_PATHNAME_LENGTH = 950;\nvar BlobAccessError = class extends BlobError {\n  constructor() {\n    super(\"Access denied, please provide a valid token for this resource.\");\n  }\n};\nvar BlobContentTypeNotAllowedError = class extends BlobError {\n  constructor(message) {\n    super(`Content type mismatch, ${message}.`);\n  }\n};\nvar BlobPathnameMismatchError = class extends BlobError {\n  constructor(message) {\n    super(\n      `Pathname mismatch, ${message}. Check the pathname used in upload() or put() matches the one from the client token.`\n    );\n  }\n};\nvar BlobClientTokenExpiredError = class extends BlobError {\n  constructor() {\n    super(\"Client token has expired.\");\n  }\n};\nvar BlobFileTooLargeError = class extends BlobError {\n  constructor(message) {\n    super(`File is too large, ${message}.`);\n  }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"This store does not exist.\");\n  }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n  constructor() {\n    super(\"This store has been suspended.\");\n  }\n};\nvar BlobUnknownError = class extends BlobError {\n  constructor() {\n    super(\"Unknown error, please visit https://vercel.com/help.\");\n  }\n};\nvar BlobNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"The requested blob does not exist\");\n  }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n  constructor() {\n    super(\"The blob service is currently not available. Please try again.\");\n  }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n  constructor(seconds) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`\n    );\n    this.retryAfter = seconds != null ? seconds : 0;\n  }\n};\nvar BlobRequestAbortedError = class extends BlobError {\n  constructor() {\n    super(\"The request was aborted.\");\n  }\n};\nvar BLOB_API_VERSION = 8;\nfunction getApiVersion() {\n  let versionOverride = null;\n  try {\n    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n  }\n  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getRetries() {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\nfunction createBlobServiceRateLimited(response) {\n  const retryAfter = response.headers.get(\"retry-after\");\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : void 0\n  );\n}\nasync function getBlobError(response) {\n  var _a3, _b2, _c;\n  let code;\n  let message;\n  try {\n    const data = await response.json();\n    code = (_b2 = (_a3 = data.error) == null ? void 0 : _a3.code) != null ? _b2 : \"unknown_error\";\n    message = (_c = data.error) == null ? void 0 : _c.message;\n  } catch {\n    code = \"unknown_error\";\n  }\n  if ((message == null ? void 0 : message.includes(\"contentType\")) && message.includes(\"is not allowed\")) {\n    code = \"content_type_not_allowed\";\n  }\n  if ((message == null ? void 0 : message.includes('\"pathname\"')) && message.includes(\"does not match the token payload\")) {\n    code = \"client_token_pathname_mismatch\";\n  }\n  if (message === \"Token expired\") {\n    code = \"client_token_expired\";\n  }\n  if (message == null ? void 0 : message.includes(\"the file length cannot be greater than\")) {\n    code = \"file_too_large\";\n  }\n  let error;\n  switch (code) {\n    case \"store_suspended\":\n      error = new BlobStoreSuspendedError();\n      break;\n    case \"forbidden\":\n      error = new BlobAccessError();\n      break;\n    case \"content_type_not_allowed\":\n      error = new BlobContentTypeNotAllowedError(message);\n      break;\n    case \"client_token_pathname_mismatch\":\n      error = new BlobPathnameMismatchError(message);\n      break;\n    case \"client_token_expired\":\n      error = new BlobClientTokenExpiredError();\n      break;\n    case \"file_too_large\":\n      error = new BlobFileTooLargeError(message);\n      break;\n    case \"not_found\":\n      error = new BlobNotFoundError();\n      break;\n    case \"store_not_found\":\n      error = new BlobStoreNotFoundError();\n      break;\n    case \"bad_request\":\n      error = new BlobError(message != null ? message : \"Bad request\");\n      break;\n    case \"service_unavailable\":\n      error = new BlobServiceNotAvailable();\n      break;\n    case \"rate_limited\":\n      error = createBlobServiceRateLimited(response);\n      break;\n    case \"unknown_error\":\n    case \"not_allowed\":\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n  return { code, error };\n}\nasync function requestApi(pathname, init, commandOptions) {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n  const [, , , storeId = \"\"] = token.split(\"_\");\n  const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n  let retryCount = 0;\n  let bodyLength = 0;\n  let totalLoaded = 0;\n  const sendBodyLength = (commandOptions == null ? void 0 : commandOptions.onUploadProgress) || shouldUseXContentLength();\n  if (init.body && // 1. For upload progress we always need to know the total size of the body\n  // 2. In development we need the header for put() to work correctly when passing a stream\n  sendBodyLength) {\n    bodyLength = computeBodyLength(init.body);\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: 0,\n      total: bodyLength,\n      percentage: 0\n    });\n  }\n  const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_3__(\n    async (bail) => {\n      let res;\n      try {\n        res = await blobRequest({\n          input: getApiUrl(pathname),\n          init: {\n            ...init,\n            headers: {\n              \"x-api-blob-request-id\": requestId,\n              \"x-api-blob-request-attempt\": String(retryCount),\n              \"x-api-version\": apiVersion,\n              ...sendBodyLength ? { \"x-content-length\": String(bodyLength) } : {},\n              authorization: `Bearer ${token}`,\n              ...extraHeaders,\n              ...init.headers\n            }\n          },\n          onUploadProgress: (commandOptions == null ? void 0 : commandOptions.onUploadProgress) ? (loaded) => {\n            var _a3;\n            const total = bodyLength !== 0 ? bodyLength : loaded;\n            totalLoaded = loaded;\n            const percentage = bodyLength > 0 ? Number((loaded / total * 100).toFixed(2)) : 0;\n            if (percentage === 100 && bodyLength > 0) {\n              return;\n            }\n            (_a3 = commandOptions.onUploadProgress) == null ? void 0 : _a3.call(commandOptions, {\n              loaded,\n              // When passing a stream to put(), we have no way to know the total size of the body.\n              // Instead of defining total as total?: number we decided to set the total to the currently\n              // loaded number. This is not inaccurate and way more practical for DX.\n              // Passing down a stream to put() is very rare\n              total,\n              percentage\n            });\n          } : void 0\n        });\n      } catch (error2) {\n        if (error2 instanceof DOMException2 && error2.name === \"AbortError\") {\n          bail(new BlobRequestAbortedError());\n          return;\n        }\n        if (isNetworkError(error2)) {\n          throw error2;\n        }\n        if (error2 instanceof TypeError) {\n          bail(error2);\n          return;\n        }\n        throw error2;\n      }\n      if (res.ok) {\n        return res;\n      }\n      const { code, error } = await getBlobError(res);\n      if (code === \"unknown_error\" || code === \"service_unavailable\" || code === \"internal_server_error\") {\n        throw error;\n      }\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        if (error instanceof Error) {\n          debug(`retrying API request to ${pathname}`, error.message);\n        }\n        retryCount = retryCount + 1;\n      }\n    }\n  );\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: totalLoaded,\n      total: totalLoaded,\n      percentage: 100\n    });\n  }\n  return await apiResponse.json();\n}\nfunction getProxyThroughAlternativeApiHeaderFromEnv() {\n  const extraHeaders = {};\n  try {\n    if (\"VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    } else if (\"NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    }\n  } catch {\n  }\n  return extraHeaders;\n}\nfunction shouldUseXContentLength() {\n  try {\n    return process.env.VERCEL_BLOB_USE_X_CONTENT_LENGTH === \"1\";\n  } catch {\n    return false;\n  }\n}\n\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n  cacheControlMaxAge: \"x-cache-control-max-age\",\n  addRandomSuffix: \"x-add-random-suffix\",\n  contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n  const headers = {};\n  if (allowedOptions.includes(\"contentType\") && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n  if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n  }\n  return headers;\n}\nasync function createPutOptions({\n  pathname,\n  options,\n  extraChecks,\n  getToken\n}) {\n  if (!pathname) {\n    throw new BlobError(\"pathname is required\");\n  }\n  if (pathname.length > MAXIMUM_PATHNAME_LENGTH) {\n    throw new BlobError(\n      `pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`\n    );\n  }\n  for (const invalidCharacter of disallowedPathnameCharacters) {\n    if (pathname.includes(invalidCharacter)) {\n      throw new BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`\n      );\n    }\n  }\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (extraChecks) {\n    extraChecks(options);\n  }\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n  return options;\n}\n\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, parts, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts\n    });\n  };\n}\nasync function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options\n}) {\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"content-type\": \"application/json\",\n          \"x-mpu-action\": \"complete\",\n          \"x-mpu-upload-id\": uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          \"x-mpu-key\": encodeURI(key)\n        },\n        body: JSON.stringify(parts),\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: complete\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId\n    };\n  };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n  debug(\"mpu: create\", \"pathname:\", pathname);\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"x-mpu-action\": \"create\"\n        },\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: create\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    }\n    throw error;\n  }\n}\n\n// src/multipart/upload.ts\n\n\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, body, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options\n    });\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber\n    };\n  };\n}\nasync function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  internalAbortController = new AbortController(),\n  part\n}) {\n  var _a3, _b2, _c;\n  const responsePromise = requestApi(\n    `/mpu/${pathname}`,\n    {\n      signal: internalAbortController.signal,\n      method: \"POST\",\n      headers: {\n        ...headers,\n        \"x-mpu-action\": \"upload\",\n        \"x-mpu-key\": encodeURI(key),\n        \"x-mpu-upload-id\": uploadId,\n        \"x-mpu-part-number\": part.partNumber.toString()\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob\n    },\n    options\n  );\n  function handleAbort() {\n    internalAbortController.abort();\n  }\n  if ((_a3 = options.abortSignal) == null ? void 0 : _a3.aborted) {\n    handleAbort();\n  } else {\n    (_b2 = options.abortSignal) == null ? void 0 : _b2.addEventListener(\"abort\", handleAbort);\n  }\n  const response = await responsePromise;\n  (_c = options.abortSignal) == null ? void 0 : _c.removeEventListener(\"abort\", handleAbort);\n  return response;\n}\nvar maxConcurrentUploads = typeof window !== \"undefined\" ? 6 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options,\n  totalToLoad\n}) {\n  debug(\"mpu: upload init\", \"key:\", key);\n  const internalAbortController = new AbortController();\n  return new Promise((resolve, reject) => {\n    const partsToUpload = [];\n    const completedParts = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n    let arrayBuffers = [];\n    let currentPartBytesRead = 0;\n    let onUploadProgress;\n    const totalLoadedPerPartNumber = {};\n    if (options.onUploadProgress) {\n      onUploadProgress = throttleit__WEBPACK_IMPORTED_MODULE_6__(() => {\n        var _a3;\n        const loaded = Object.values(totalLoadedPerPartNumber).reduce(\n          (acc, cur) => {\n            return acc + cur;\n          },\n          0\n        );\n        const total = totalToLoad || loaded;\n        const percentage = totalToLoad > 0 ? Number(((loaded / totalToLoad || loaded) * 100).toFixed(2)) : 0;\n        (_a3 = options.onUploadProgress) == null ? void 0 : _a3.call(options, { loaded, total, percentage });\n      }, 150);\n    }\n    read().catch(cancel);\n    async function read() {\n      debug(\n        \"mpu: upload read start\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_5__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_5__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_5__(bytesSent)\n      );\n      reading = true;\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          const { value, done } = await reader.read();\n          if (done) {\n            doneReading = true;\n            debug(\"mpu: upload read consumed the whole stream\");\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n          currentBytesInMemory += value.byteLength;\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength\n            );\n            const chunk = value.slice(valueOffset, endOffset);\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n      debug(\n        \"mpu: upload read end\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_5__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_5__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_5__(bytesSent)\n      );\n      reading = false;\n    }\n    async function sendPart(part) {\n      activeUploads++;\n      debug(\n        \"mpu: upload send part start\",\n        \"partNumber:\",\n        part.partNumber,\n        \"size:\",\n        part.blob.size,\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_5__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_5__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_5__(bytesSent)\n      );\n      try {\n        const uploadProgressForPart = options.onUploadProgress ? (event) => {\n          totalLoadedPerPartNumber[part.partNumber] = event.loaded;\n          if (onUploadProgress) {\n            onUploadProgress();\n          }\n        } : void 0;\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options: {\n            ...options,\n            onUploadProgress: uploadProgressForPart\n          },\n          internalAbortController,\n          part\n        });\n        debug(\n          \"mpu: upload send part end\",\n          \"partNumber:\",\n          part.partNumber,\n          \"activeUploads\",\n          activeUploads,\n          \"currentBytesInMemory:\",\n          `${bytes__WEBPACK_IMPORTED_MODULE_5__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_5__(maxBytesInMemory)}`,\n          \"bytesSent:\",\n          bytes__WEBPACK_IMPORTED_MODULE_5__(bytesSent)\n        );\n        if (rejected) {\n          return;\n        }\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag\n        });\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n    function sendParts() {\n      if (rejected) {\n        return;\n      }\n      debug(\n        \"send parts\",\n        \"activeUploads\",\n        activeUploads,\n        \"partsToUpload\",\n        partsToUpload.length\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n    function cancel(error) {\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\n// src/put.ts\n\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n  debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n  const optionsWithoutOnUploadProgress = {\n    ...options,\n    onUploadProgress: void 0\n  };\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    optionsWithoutOnUploadProgress\n  );\n  const totalToLoad = computeBodyLength(body);\n  const stream = await toReadableStream(body);\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n    totalToLoad\n  });\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options: optionsWithoutOnUploadProgress\n  });\n  return blob;\n}\n\n// src/put.ts\nfunction createPutMethod({\n  allowedOptions,\n  getToken,\n  extraChecks\n}) {\n  return async function put(pathname, body, optionsInput) {\n    if (!body) {\n      throw new BlobError(\"body is required\");\n    }\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (options.multipart === true) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n    const onUploadProgress = options.onUploadProgress ? throttleit__WEBPACK_IMPORTED_MODULE_6__(options.onUploadProgress, 100) : void 0;\n    const response = await requestApi(\n      `/${pathname}`,\n      {\n        method: \"PUT\",\n        body,\n        headers,\n        signal: options.abortSignal\n      },\n      {\n        ...options,\n        onUploadProgress\n      }\n    );\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition\n    };\n  };\n}\n\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n      async uploadPart(partNumber, body) {\n        if (isPlainObject(body)) {\n          throw new BlobError(\n            \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n          );\n        }\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options\n        });\n        return {\n          etag: result.etag,\n          partNumber\n        };\n      },\n      async complete(parts) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options\n        });\n      }\n    };\n  };\n}\n\n// src/create-folder.ts\nasync function createFolder(pathname, options = {}) {\n  const path = pathname.endsWith(\"/\") ? pathname : `${pathname}/`;\n  const headers = {};\n  headers[putOptionHeaderMap.addRandomSuffix] = \"0\";\n  const response = await requestApi(\n    `/${path}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    pathname: response.pathname\n  };\n}\n\n\n//# sourceMappingURL=chunk-KN6WT5GP.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstS042V1Q1R1AuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2dEOztBQUVoRDtBQUNrQztBQUNEO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0NBQVE7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4REFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSw2Q0FBNkMsRUFBRSxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQsc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMkJFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nYWRhaS1yYWNvbXAvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstS042V1Q1R1AuanM/MmM0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaGVscGVycy50c1xuaW1wb3J0IHsgaXNOb2RlUHJvY2VzcyB9IGZyb20gXCJpcy1ub2RlLXByb2Nlc3NcIjtcblxuLy8gc3JjL211bHRpcGFydC9oZWxwZXJzLnRzXG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gXCJzdHJlYW1cIjtcbmltcG9ydCBpc0J1ZmZlciBmcm9tIFwiaXMtYnVmZmVyXCI7XG52YXIgc3VwcG9ydHNOZXdCbG9iRnJvbUFycmF5QnVmZmVyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBoZWxsb0FzQXJyYXlCdWZmZXIgPSBuZXcgVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTFdKTtcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2hlbGxvQXNBcnJheUJ1ZmZlcl0pO1xuICAgIGJsb2IudGV4dCgpLnRoZW4oKHRleHQpID0+IHtcbiAgICAgIHJlc29sdmUodGV4dCA9PT0gXCJoZWxsb1wiKTtcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSBjYXRjaCB7XG4gICAgcmVzb2x2ZShmYWxzZSk7XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gdG9SZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIHZhbHVlLnN0cmVhbSgpO1xuICB9XG4gIGlmIChpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiBSZWFkYWJsZS50b1dlYih2YWx1ZSk7XG4gIH1cbiAgbGV0IHN0cmVhbVZhbHVlO1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHN0cmVhbVZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTm9kZUpzQnVmZmVyKHZhbHVlKSkge1xuICAgIHN0cmVhbVZhbHVlID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtVmFsdWUgPSBzdHJpbmdUb1VpbnQ4QXJyYXkodmFsdWUpO1xuICB9XG4gIGlmIChhd2FpdCBzdXBwb3J0c05ld0Jsb2JGcm9tQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW3N0cmVhbVZhbHVlXSkuc3RyZWFtKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHN0cmVhbVZhbHVlKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5waXBlID09PSBcImZ1bmN0aW9uXCIgJiYgdmFsdWUucmVhZGFibGUgJiYgdHlwZW9mIHZhbHVlLl9yZWFkID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gQHRzLWV4cGVjdC1lcnJvciBfcmVhZGFibGVTdGF0ZSBkb2VzIGV4aXN0cyBvbiBSZWFkYWJsZVxuICB0eXBlb2YgdmFsdWUuX3JlYWRhYmxlU3RhdGUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VpbnQ4QXJyYXkocykge1xuICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgcmV0dXJuIGVuYy5lbmNvZGUocyk7XG59XG5mdW5jdGlvbiBpc05vZGVKc0J1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gaXNCdWZmZXIodmFsdWUpO1xufVxuXG4vLyBzcmMvaGVscGVycy50c1xuZnVuY3Rpb24gZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW4pIHtcbiAgICByZXR1cm4gb3B0aW9ucy50b2tlbjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuQkxPQl9SRUFEX1dSSVRFX1RPS0VOKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkJMT0JfUkVBRF9XUklURV9UT0tFTjtcbiAgfVxuICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgIFwiTm8gdG9rZW4gZm91bmQuIEVpdGhlciBjb25maWd1cmUgdGhlIGBCTE9CX1JFQURfV1JJVEVfVE9LRU5gIGVudmlyb25tZW50IHZhcmlhYmxlLCBvciBwYXNzIGEgYHRva2VuYCBvcHRpb24gdG8geW91ciBjYWxscy5cIlxuICApO1xufVxudmFyIEJsb2JFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYFZlcmNlbCBCbG9iOiAke21lc3NhZ2V9YCk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXREb3dubG9hZFVybChibG9iVXJsKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoYmxvYlVybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiZG93bmxvYWRcIiwgXCIxXCIpO1xuICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgcmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpO1xufVxudmFyIGRpc2FsbG93ZWRQYXRobmFtZUNoYXJhY3RlcnMgPSBbXCIjXCIsIFwiP1wiLCBcIi8vXCJdO1xudmFyIHN1cHBvcnRzUmVxdWVzdFN0cmVhbXMgPSAoKCkgPT4ge1xuICBpZiAoaXNOb2RlUHJvY2VzcygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IGR1cGxleEFjY2Vzc2VkID0gZmFsc2U7XG4gIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gbmV3IFJlcXVlc3QoZ2V0QXBpVXJsKCksIHtcbiAgICBib2R5OiBuZXcgUmVhZGFibGVTdHJlYW0oKSxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gVHlwZVNjcmlwdCBkb2Vzbid0IHlldCBoYXZlIGR1cGxleCBidXQgaXQncyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0LURPTS1saWItZ2VuZXJhdG9yL3B1bGwvMTcyOVxuICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICByZXR1cm4gXCJoYWxmXCI7XG4gICAgfVxuICB9KS5oZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKTtcbiAgcmV0dXJuIGR1cGxleEFjY2Vzc2VkICYmICFoYXNDb250ZW50VHlwZTtcbn0pKCk7XG5mdW5jdGlvbiBnZXRBcGlVcmwocGF0aG5hbWUgPSBcIlwiKSB7XG4gIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQVBJX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVVJMO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7YmFzZVVybCB8fCBcImh0dHBzOi8vYmxvYi52ZXJjZWwtc3RvcmFnZS5jb21cIn0ke3BhdGhuYW1lfWA7XG59XG52YXIgVEVYVF9FTkNPREVSID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGw7XG5mdW5jdGlvbiBjb21wdXRlQm9keUxlbmd0aChib2R5KSB7XG4gIGlmICghYm9keSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChURVhUX0VOQ09ERVIpIHtcbiAgICAgIHJldHVybiBURVhUX0VOQ09ERVIuZW5jb2RlKGJvZHkpLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmxvYihbYm9keV0pLnNpemU7XG4gIH1cbiAgaWYgKFwiYnl0ZUxlbmd0aFwiIGluIGJvZHkgJiYgdHlwZW9mIGJvZHkuYnl0ZUxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gIH1cbiAgaWYgKFwic2l6ZVwiIGluIGJvZHkgJiYgdHlwZW9mIGJvZHkuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBib2R5LnNpemU7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgY3JlYXRlQ2h1bmtUcmFuc2Zvcm1TdHJlYW0gPSAoY2h1bmtTaXplLCBvblByb2dyZXNzKSA9PiB7XG4gIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIubGVuZ3RoICsgY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldChuZXcgVWludDhBcnJheShjaHVuayksIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBidWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoID49IGNodW5rU2l6ZSkge1xuICAgICAgICAgIGNvbnN0IG5ld0NodW5rID0gYnVmZmVyLnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ld0NodW5rKTtcbiAgICAgICAgICBvblByb2dyZXNzID09IG51bGwgPyB2b2lkIDAgOiBvblByb2dyZXNzKG5ld0NodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShjaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICAgICAgb25Qcm9ncmVzcyA9PSBudWxsID8gdm9pZCAwIDogb25Qcm9ncmVzcyhidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIE5vdCBwcmVzZW50IGluIE5vZGUuanMgMTZcbiAgICBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtICYmIC8vIFRPRE86IENhbiBiZSByZW1vdmVkIG9uY2UgTm9kZS5qcyAxNiBpcyBubyBtb3JlIHJlcXVpcmVkIGludGVybmFsbHlcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtXG4gICk7XG59XG5mdW5jdGlvbiBpc1N0cmVhbSh2YWx1ZSkge1xuICBpZiAoaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9hcGkudHNcbmltcG9ydCByZXRyeSBmcm9tIFwiYXN5bmMtcmV0cnlcIjtcblxuLy8gc3JjL2lzLW5ldHdvcmstZXJyb3IudHNcbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNFcnJvciA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBFcnJvcl1cIjtcbnZhciBlcnJvck1lc3NhZ2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIm5ldHdvcmsgZXJyb3JcIixcbiAgLy8gQ2hyb21lXG4gIFwiRmFpbGVkIHRvIGZldGNoXCIsXG4gIC8vIENocm9tZVxuICBcIk5ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuXCIsXG4gIC8vIEZpcmVmb3hcbiAgXCJUaGUgSW50ZXJuZXQgY29ubmVjdGlvbiBhcHBlYXJzIHRvIGJlIG9mZmxpbmUuXCIsXG4gIC8vIFNhZmFyaSAxNlxuICBcIkxvYWQgZmFpbGVkXCIsXG4gIC8vIFNhZmFyaSAxNytcbiAgXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkXCIsXG4gIC8vIGBjcm9zcy1mZXRjaGBcbiAgXCJmZXRjaCBmYWlsZWRcIixcbiAgLy8gVW5kaWNpIChOb2RlLmpzKVxuICBcInRlcm1pbmF0ZWRcIlxuICAvLyBVbmRpY2kgKE5vZGUuanMpXG5dKTtcbmZ1bmN0aW9uIGlzTmV0d29ya0Vycm9yKGVycm9yKSB7XG4gIGNvbnN0IGlzVmFsaWQgPSBlcnJvciAmJiBpc0Vycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSBcIlR5cGVFcnJvclwiICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSBcInN0cmluZ1wiO1xuICBpZiAoIWlzVmFsaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVycm9yLm1lc3NhZ2UgPT09IFwiTG9hZCBmYWlsZWRcIikge1xuICAgIHJldHVybiBlcnJvci5zdGFjayA9PT0gdm9pZCAwO1xuICB9XG4gIHJldHVybiBlcnJvck1lc3NhZ2VzLmhhcyhlcnJvci5tZXNzYWdlKTtcbn1cblxuLy8gc3JjL2RlYnVnLnRzXG52YXIgZGVidWdJc0FjdGl2ZSA9IGZhbHNlO1xudmFyIF9hLCBfYjtcbnRyeSB7XG4gIGlmICgoKF9hID0gcHJvY2Vzcy5lbnYuREVCVUcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcImJsb2JcIikpIHx8ICgoX2IgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiYmxvYlwiKSkpIHtcbiAgICBkZWJ1Z0lzQWN0aXZlID0gdHJ1ZTtcbiAgfVxufSBjYXRjaCAoZXJyb3IpIHtcbn1cbmZ1bmN0aW9uIGRlYnVnKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgaWYgKGRlYnVnSXNBY3RpdmUpIHtcbiAgICBjb25zb2xlLmRlYnVnKGB2ZXJjZWwtYmxvYjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xuICB9XG59XG5cbi8vIHNyYy9mZXRjaC50c1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwidW5kaWNpXCI7XG52YXIgaGFzRmV0Y2ggPSB0eXBlb2YgZmV0Y2ggPT09IFwiZnVuY3Rpb25cIjtcbnZhciBoYXNGZXRjaFdpdGhVcGxvYWRQcm9ncmVzcyA9IGhhc0ZldGNoICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbXM7XG52YXIgQ0hVTktfU0laRSA9IDY0ICogMTAyNDtcbnZhciBibG9iRmV0Y2ggPSBhc3luYyAoe1xuICBpbnB1dCxcbiAgaW5pdCxcbiAgb25VcGxvYWRQcm9ncmVzc1xufSkgPT4ge1xuICBkZWJ1ZyhcInVzaW5nIGZldGNoXCIpO1xuICBsZXQgYm9keTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0b1JlYWRhYmxlU3RyZWFtKGluaXQuYm9keSk7XG4gICAgICBsZXQgbG9hZGVkID0gMDtcbiAgICAgIGNvbnN0IGNodW5rVHJhbnNmb3JtU3RyZWFtID0gY3JlYXRlQ2h1bmtUcmFuc2Zvcm1TdHJlYW0oXG4gICAgICAgIENIVU5LX1NJWkUsXG4gICAgICAgIChuZXdMb2FkZWQpID0+IHtcbiAgICAgICAgICBsb2FkZWQgKz0gbmV3TG9hZGVkO1xuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MobG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGJvZHkgPSBzdHJlYW0ucGlwZVRocm91Z2goY2h1bmtUcmFuc2Zvcm1TdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gaW5pdC5ib2R5O1xuICAgIH1cbiAgfVxuICBjb25zdCBkdXBsZXggPSBzdXBwb3J0c1JlcXVlc3RTdHJlYW1zICYmIGJvZHkgJiYgaXNTdHJlYW0oYm9keSkgPyBcImhhbGZcIiA6IHZvaWQgMDtcbiAgcmV0dXJuIGZldGNoKFxuICAgIGlucHV0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gQmxvYiBhbmQgTm9kZWpzIEJsb2IgYXJlIHRyaWdnZXJpbmcgdHlwZSBlcnJvcnMsIGZpbmUgd2l0aCBpdFxuICAgIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICAuLi5pbml0LmJvZHkgPyB7IGJvZHkgfSA6IHt9LFxuICAgICAgZHVwbGV4XG4gICAgfVxuICApO1xufTtcblxuLy8gc3JjL3hoci50c1xudmFyIGhhc1hociA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBibG9iWGhyID0gYXN5bmMgKHtcbiAgaW5wdXQsXG4gIGluaXQsXG4gIG9uVXBsb2FkUHJvZ3Jlc3Ncbn0pID0+IHtcbiAgZGVidWcoXCJ1c2luZyB4aHJcIik7XG4gIGxldCBib2R5ID0gbnVsbDtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGlmIChpc1JlYWRhYmxlU3RyZWFtKGluaXQuYm9keSkpIHtcbiAgICAgIGJvZHkgPSBhd2FpdCBuZXcgUmVzcG9uc2UoaW5pdC5ib2R5KS5ibG9iKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSBpbml0LmJvZHk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oaW5pdC5tZXRob2QgfHwgXCJHRVRcIiwgaW5wdXQudG9TdHJpbmcoKSwgdHJ1ZSk7XG4gICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MoZXZlbnQubG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgaWYgKChfYTMgPSBpbml0LnNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5hYm9ydGVkKSB7XG4gICAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFwiVGhlIHVzZXIgYWJvcnRlZCB0aGUgcmVxdWVzdC5cIiwgXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICBjb25zdCByYXdIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyk7XG4gICAgICByYXdIZWFkZXJzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KFwiOiBcIik7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFydHMuam9pbihcIjogXCIpO1xuICAgICAgICBpZiAoa2V5KSBoZWFkZXJzLnNldChrZXkudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZSh4aHIucmVzcG9uc2UsIHtcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkXCIpKTtcbiAgICB9O1xuICAgIHhoci5vbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IFR5cGVFcnJvcihcIk5ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXRcIikpO1xuICAgIH07XG4gICAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbihcIlRoZSB1c2VyIGFib3J0ZWQgYSByZXF1ZXN0LlwiLCBcIkFib3J0RXJyb3JcIikpO1xuICAgIH07XG4gICAgaWYgKGluaXQuaGVhZGVycykge1xuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluaXQuc2lnbmFsKSB7XG4gICAgICBpbml0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluaXQuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgeGhyLnNlbmQoYm9keSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL3JlcXVlc3QudHNcbnZhciBibG9iUmVxdWVzdCA9IGFzeW5jICh7XG4gIGlucHV0LFxuICBpbml0LFxuICBvblVwbG9hZFByb2dyZXNzXG59KSA9PiB7XG4gIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgaWYgKGhhc0ZldGNoV2l0aFVwbG9hZFByb2dyZXNzKSB7XG4gICAgICByZXR1cm4gYmxvYkZldGNoKHsgaW5wdXQsIGluaXQsIG9uVXBsb2FkUHJvZ3Jlc3MgfSk7XG4gICAgfVxuICAgIGlmIChoYXNYaHIpIHtcbiAgICAgIHJldHVybiBibG9iWGhyKHsgaW5wdXQsIGluaXQsIG9uVXBsb2FkUHJvZ3Jlc3MgfSk7XG4gICAgfVxuICB9XG4gIGlmIChoYXNGZXRjaCkge1xuICAgIHJldHVybiBibG9iRmV0Y2goeyBpbnB1dCwgaW5pdCB9KTtcbiAgfVxuICBpZiAoaGFzWGhyKSB7XG4gICAgcmV0dXJuIGJsb2JYaHIoeyBpbnB1dCwgaW5pdCB9KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXF1ZXN0IGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZVwiKTtcbn07XG5cbi8vIHNyYy9kb20tZXhjZXB0aW9uLnRzXG52YXIgX2EyO1xudmFyIERPTUV4Y2VwdGlvbjIgPSAoX2EyID0gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pICE9IG51bGwgPyBfYTIgOiAoKCkgPT4ge1xuICB0cnkge1xuICAgIGF0b2IoXCJ+XCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVycikuY29uc3RydWN0b3I7XG4gIH1cbn0pKCk7XG5cbi8vIHNyYy9hcGkudHNcbnZhciBNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSCA9IDk1MDtcbnZhciBCbG9iQWNjZXNzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiQWNjZXNzIGRlbmllZCwgcGxlYXNlIHByb3ZpZGUgYSB2YWxpZCB0b2tlbiBmb3IgdGhpcyByZXNvdXJjZS5cIik7XG4gIH1cbn07XG52YXIgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYENvbnRlbnQgdHlwZSBtaXNtYXRjaCwgJHttZXNzYWdlfS5gKTtcbiAgfVxufTtcbnZhciBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgUGF0aG5hbWUgbWlzbWF0Y2gsICR7bWVzc2FnZX0uIENoZWNrIHRoZSBwYXRobmFtZSB1c2VkIGluIHVwbG9hZCgpIG9yIHB1dCgpIG1hdGNoZXMgdGhlIG9uZSBmcm9tIHRoZSBjbGllbnQgdG9rZW4uYFxuICAgICk7XG4gIH1cbn07XG52YXIgQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkNsaWVudCB0b2tlbiBoYXMgZXhwaXJlZC5cIik7XG4gIH1cbn07XG52YXIgQmxvYkZpbGVUb29MYXJnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYEZpbGUgaXMgdG9vIGxhcmdlLCAke21lc3NhZ2V9LmApO1xuICB9XG59O1xudmFyIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhpcyBzdG9yZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gIH1cbn07XG52YXIgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhpcyBzdG9yZSBoYXMgYmVlbiBzdXNwZW5kZWQuXCIpO1xuICB9XG59O1xudmFyIEJsb2JVbmtub3duRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVW5rbm93biBlcnJvciwgcGxlYXNlIHZpc2l0IGh0dHBzOi8vdmVyY2VsLmNvbS9oZWxwLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGUgcmVxdWVzdGVkIGJsb2IgZG9lcyBub3QgZXhpc3RcIik7XG4gIH1cbn07XG52YXIgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIGJsb2Igc2VydmljZSBpcyBjdXJyZW50bHkgbm90IGF2YWlsYWJsZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gIH1cbn07XG52YXIgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2Vjb25kcykge1xuICAgIHN1cGVyKFxuICAgICAgYFRvbyBtYW55IHJlcXVlc3RzIHBsZWFzZSBsb3dlciB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVxdWVzdHMgJHtzZWNvbmRzID8gYCAtIHRyeSBhZ2FpbiBpbiAke3NlY29uZHN9IHNlY29uZHNgIDogXCJcIn0uYFxuICAgICk7XG4gICAgdGhpcy5yZXRyeUFmdGVyID0gc2Vjb25kcyAhPSBudWxsID8gc2Vjb25kcyA6IDA7XG4gIH1cbn07XG52YXIgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQuXCIpO1xuICB9XG59O1xudmFyIEJMT0JfQVBJX1ZFUlNJT04gPSA4O1xuZnVuY3Rpb24gZ2V0QXBpVmVyc2lvbigpIHtcbiAgbGV0IHZlcnNpb25PdmVycmlkZSA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmVyc2lvbk92ZXJyaWRlID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQVBJX1ZFUlNJT05fT1ZFUlJJREUgfHwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVkVSQ0VMX0JMT0JfQVBJX1ZFUlNJT05fT1ZFUlJJREU7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBgJHt2ZXJzaW9uT3ZlcnJpZGUgIT0gbnVsbCA/IHZlcnNpb25PdmVycmlkZSA6IEJMT0JfQVBJX1ZFUlNJT059YDtcbn1cbmZ1bmN0aW9uIGdldFJldHJpZXMoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmV0cmllcyA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX1JFVFJJRVMgfHwgXCIxMFwiO1xuICAgIHJldHVybiBwYXJzZUludChyZXRyaWVzLCAxMCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAxMDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQmxvYlNlcnZpY2VSYXRlTGltaXRlZChyZXNwb25zZSkge1xuICBjb25zdCByZXRyeUFmdGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJyZXRyeS1hZnRlclwiKTtcbiAgcmV0dXJuIG5ldyBCbG9iU2VydmljZVJhdGVMaW1pdGVkKFxuICAgIHJldHJ5QWZ0ZXIgPyBwYXJzZUludChyZXRyeUFmdGVyLCAxMCkgOiB2b2lkIDBcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEJsb2JFcnJvcihyZXNwb25zZSkge1xuICB2YXIgX2EzLCBfYjIsIF9jO1xuICBsZXQgY29kZTtcbiAgbGV0IG1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb2RlID0gKF9iMiA9IChfYTMgPSBkYXRhLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNvZGUpICE9IG51bGwgPyBfYjIgOiBcInVua25vd25fZXJyb3JcIjtcbiAgICBtZXNzYWdlID0gKF9jID0gZGF0YS5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm1lc3NhZ2U7XG4gIH0gY2F0Y2gge1xuICAgIGNvZGUgPSBcInVua25vd25fZXJyb3JcIjtcbiAgfVxuICBpZiAoKG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaW5jbHVkZXMoXCJjb250ZW50VHlwZVwiKSkgJiYgbWVzc2FnZS5pbmNsdWRlcyhcImlzIG5vdCBhbGxvd2VkXCIpKSB7XG4gICAgY29kZSA9IFwiY29udGVudF90eXBlX25vdF9hbGxvd2VkXCI7XG4gIH1cbiAgaWYgKChtZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlLmluY2x1ZGVzKCdcInBhdGhuYW1lXCInKSkgJiYgbWVzc2FnZS5pbmNsdWRlcyhcImRvZXMgbm90IG1hdGNoIHRoZSB0b2tlbiBwYXlsb2FkXCIpKSB7XG4gICAgY29kZSA9IFwiY2xpZW50X3Rva2VuX3BhdGhuYW1lX21pc21hdGNoXCI7XG4gIH1cbiAgaWYgKG1lc3NhZ2UgPT09IFwiVG9rZW4gZXhwaXJlZFwiKSB7XG4gICAgY29kZSA9IFwiY2xpZW50X3Rva2VuX2V4cGlyZWRcIjtcbiAgfVxuICBpZiAobWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZS5pbmNsdWRlcyhcInRoZSBmaWxlIGxlbmd0aCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuXCIpKSB7XG4gICAgY29kZSA9IFwiZmlsZV90b29fbGFyZ2VcIjtcbiAgfVxuICBsZXQgZXJyb3I7XG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgXCJzdG9yZV9zdXNwZW5kZWRcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZm9yYmlkZGVuXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iQWNjZXNzRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb250ZW50X3R5cGVfbm90X2FsbG93ZWRcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JDb250ZW50VHlwZU5vdEFsbG93ZWRFcnJvcihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjbGllbnRfdG9rZW5fcGF0aG5hbWVfbWlzbWF0Y2hcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JQYXRobmFtZU1pc21hdGNoRXJyb3IobWVzc2FnZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xpZW50X3Rva2VuX2V4cGlyZWRcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JDbGllbnRUb2tlbkV4cGlyZWRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVfdG9vX2xhcmdlXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iRmlsZVRvb0xhcmdlRXJyb3IobWVzc2FnZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibm90X2ZvdW5kXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iTm90Rm91bmRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0b3JlX25vdF9mb3VuZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlN0b3JlTm90Rm91bmRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJhZF9yZXF1ZXN0XCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iRXJyb3IobWVzc2FnZSAhPSBudWxsID8gbWVzc2FnZSA6IFwiQmFkIHJlcXVlc3RcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic2VydmljZV91bmF2YWlsYWJsZVwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyYXRlX2xpbWl0ZWRcIjpcbiAgICAgIGVycm9yID0gY3JlYXRlQmxvYlNlcnZpY2VSYXRlTGltaXRlZChyZXNwb25zZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidW5rbm93bl9lcnJvclwiOlxuICAgIGNhc2UgXCJub3RfYWxsb3dlZFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iVW5rbm93bkVycm9yKCk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geyBjb2RlLCBlcnJvciB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEFwaShwYXRobmFtZSwgaW5pdCwgY29tbWFuZE9wdGlvbnMpIHtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IGdldEFwaVZlcnNpb24oKTtcbiAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYoY29tbWFuZE9wdGlvbnMpO1xuICBjb25zdCBleHRyYUhlYWRlcnMgPSBnZXRQcm94eVRocm91Z2hBbHRlcm5hdGl2ZUFwaUhlYWRlckZyb21FbnYoKTtcbiAgY29uc3QgWywgLCAsIHN0b3JlSWQgPSBcIlwiXSA9IHRva2VuLnNwbGl0KFwiX1wiKTtcbiAgY29uc3QgcmVxdWVzdElkID0gYCR7c3RvcmVJZH06JHtEYXRlLm5vdygpfToke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKDIpfWA7XG4gIGxldCByZXRyeUNvdW50ID0gMDtcbiAgbGV0IGJvZHlMZW5ndGggPSAwO1xuICBsZXQgdG90YWxMb2FkZWQgPSAwO1xuICBjb25zdCBzZW5kQm9keUxlbmd0aCA9IChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykgfHwgc2hvdWxkVXNlWENvbnRlbnRMZW5ndGgoKTtcbiAgaWYgKGluaXQuYm9keSAmJiAvLyAxLiBGb3IgdXBsb2FkIHByb2dyZXNzIHdlIGFsd2F5cyBuZWVkIHRvIGtub3cgdGhlIHRvdGFsIHNpemUgb2YgdGhlIGJvZHlcbiAgLy8gMi4gSW4gZGV2ZWxvcG1lbnQgd2UgbmVlZCB0aGUgaGVhZGVyIGZvciBwdXQoKSB0byB3b3JrIGNvcnJlY3RseSB3aGVuIHBhc3NpbmcgYSBzdHJlYW1cbiAgc2VuZEJvZHlMZW5ndGgpIHtcbiAgICBib2R5TGVuZ3RoID0gY29tcHV0ZUJvZHlMZW5ndGgoaW5pdC5ib2R5KTtcbiAgfVxuICBpZiAoY29tbWFuZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKHtcbiAgICAgIGxvYWRlZDogMCxcbiAgICAgIHRvdGFsOiBib2R5TGVuZ3RoLFxuICAgICAgcGVyY2VudGFnZTogMFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGFwaVJlc3BvbnNlID0gYXdhaXQgcmV0cnkoXG4gICAgYXN5bmMgKGJhaWwpID0+IHtcbiAgICAgIGxldCByZXM7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBhd2FpdCBibG9iUmVxdWVzdCh7XG4gICAgICAgICAgaW5wdXQ6IGdldEFwaVVybChwYXRobmFtZSksXG4gICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgXCJ4LWFwaS1ibG9iLXJlcXVlc3QtaWRcIjogcmVxdWVzdElkLFxuICAgICAgICAgICAgICBcIngtYXBpLWJsb2ItcmVxdWVzdC1hdHRlbXB0XCI6IFN0cmluZyhyZXRyeUNvdW50KSxcbiAgICAgICAgICAgICAgXCJ4LWFwaS12ZXJzaW9uXCI6IGFwaVZlcnNpb24sXG4gICAgICAgICAgICAgIC4uLnNlbmRCb2R5TGVuZ3RoID8geyBcIngtY29udGVudC1sZW5ndGhcIjogU3RyaW5nKGJvZHlMZW5ndGgpIH0gOiB7fSxcbiAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICAgIC4uLmV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgLi4uaW5pdC5oZWFkZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiAoY29tbWFuZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpID8gKGxvYWRlZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gYm9keUxlbmd0aCAhPT0gMCA/IGJvZHlMZW5ndGggOiBsb2FkZWQ7XG4gICAgICAgICAgICB0b3RhbExvYWRlZCA9IGxvYWRlZDtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBib2R5TGVuZ3RoID4gMCA/IE51bWJlcigobG9hZGVkIC8gdG90YWwgKiAxMDApLnRvRml4ZWQoMikpIDogMDtcbiAgICAgICAgICAgIGlmIChwZXJjZW50YWdlID09PSAxMDAgJiYgYm9keUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hMyA9IGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbChjb21tYW5kT3B0aW9ucywge1xuICAgICAgICAgICAgICBsb2FkZWQsXG4gICAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBhIHN0cmVhbSB0byBwdXQoKSwgd2UgaGF2ZSBubyB3YXkgdG8ga25vdyB0aGUgdG90YWwgc2l6ZSBvZiB0aGUgYm9keS5cbiAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBkZWZpbmluZyB0b3RhbCBhcyB0b3RhbD86IG51bWJlciB3ZSBkZWNpZGVkIHRvIHNldCB0aGUgdG90YWwgdG8gdGhlIGN1cnJlbnRseVxuICAgICAgICAgICAgICAvLyBsb2FkZWQgbnVtYmVyLiBUaGlzIGlzIG5vdCBpbmFjY3VyYXRlIGFuZCB3YXkgbW9yZSBwcmFjdGljYWwgZm9yIERYLlxuICAgICAgICAgICAgICAvLyBQYXNzaW5nIGRvd24gYSBzdHJlYW0gdG8gcHV0KCkgaXMgdmVyeSByYXJlXG4gICAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgICBwZXJjZW50YWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBET01FeGNlcHRpb24yICYmIGVycm9yMi5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgIGJhaWwobmV3IEJsb2JSZXF1ZXN0QWJvcnRlZEVycm9yKCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXR3b3JrRXJyb3IoZXJyb3IyKSkge1xuICAgICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgYmFpbChlcnJvcjIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjI7XG4gICAgICB9XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGNvZGUsIGVycm9yIH0gPSBhd2FpdCBnZXRCbG9iRXJyb3IocmVzKTtcbiAgICAgIGlmIChjb2RlID09PSBcInVua25vd25fZXJyb3JcIiB8fCBjb2RlID09PSBcInNlcnZpY2VfdW5hdmFpbGFibGVcIiB8fCBjb2RlID09PSBcImludGVybmFsX3NlcnZlcl9lcnJvclwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgYmFpbChlcnJvcik7XG4gICAgfSxcbiAgICB7XG4gICAgICByZXRyaWVzOiBnZXRSZXRyaWVzKCksXG4gICAgICBvblJldHJ5OiAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBkZWJ1ZyhgcmV0cnlpbmcgQVBJIHJlcXVlc3QgdG8gJHtwYXRobmFtZX1gLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXRyeUNvdW50ID0gcmV0cnlDb3VudCArIDE7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBpZiAoIWFwaVJlc3BvbnNlKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JVbmtub3duRXJyb3IoKTtcbiAgfVxuICBpZiAoY29tbWFuZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKHtcbiAgICAgIGxvYWRlZDogdG90YWxMb2FkZWQsXG4gICAgICB0b3RhbDogdG90YWxMb2FkZWQsXG4gICAgICBwZXJjZW50YWdlOiAxMDBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXdhaXQgYXBpUmVzcG9uc2UuanNvbigpO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlUaHJvdWdoQWx0ZXJuYXRpdmVBcGlIZWFkZXJGcm9tRW52KCkge1xuICBjb25zdCBleHRyYUhlYWRlcnMgPSB7fTtcbiAgdHJ5IHtcbiAgICBpZiAoXCJWRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSVwiIGluIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJICE9PSB2b2lkIDApIHtcbiAgICAgIGV4dHJhSGVhZGVyc1tcIngtcHJveHktdGhyb3VnaC1hbHRlcm5hdGl2ZS1hcGlcIl0gPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSTtcbiAgICB9IGVsc2UgaWYgKFwiTkVYVF9QVUJMSUNfVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUElcIiBpbiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSSAhPT0gdm9pZCAwKSB7XG4gICAgICBleHRyYUhlYWRlcnNbXCJ4LXByb3h5LXRocm91Z2gtYWx0ZXJuYXRpdmUtYXBpXCJdID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUEk7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gZXh0cmFIZWFkZXJzO1xufVxuZnVuY3Rpb24gc2hvdWxkVXNlWENvbnRlbnRMZW5ndGgoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX1VTRV9YX0NPTlRFTlRfTEVOR1RIID09PSBcIjFcIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIHNyYy9wdXQtaGVscGVycy50c1xudmFyIHB1dE9wdGlvbkhlYWRlck1hcCA9IHtcbiAgY2FjaGVDb250cm9sTWF4QWdlOiBcIngtY2FjaGUtY29udHJvbC1tYXgtYWdlXCIsXG4gIGFkZFJhbmRvbVN1ZmZpeDogXCJ4LWFkZC1yYW5kb20tc3VmZml4XCIsXG4gIGNvbnRlbnRUeXBlOiBcIngtY29udGVudC10eXBlXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiY29udGVudFR5cGVcIikgJiYgb3B0aW9ucy5jb250ZW50VHlwZSkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmNvbnRlbnRUeXBlXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiYWRkUmFuZG9tU3VmZml4XCIpICYmIG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5hZGRSYW5kb21TdWZmaXhdID0gb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggPyBcIjFcIiA6IFwiMFwiO1xuICB9XG4gIGlmIChhbGxvd2VkT3B0aW9ucy5pbmNsdWRlcyhcImNhY2hlQ29udHJvbE1heEFnZVwiKSAmJiBvcHRpb25zLmNhY2hlQ29udHJvbE1heEFnZSAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuY2FjaGVDb250cm9sTWF4QWdlXSA9IG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVQdXRPcHRpb25zKHtcbiAgcGF0aG5hbWUsXG4gIG9wdGlvbnMsXG4gIGV4dHJhQ2hlY2tzLFxuICBnZXRUb2tlblxufSkge1xuICBpZiAoIXBhdGhuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcInBhdGhuYW1lIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGlmIChwYXRobmFtZS5sZW5ndGggPiBNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICBgcGF0aG5hbWUgaXMgdG9vIGxvbmcsIG1heGltdW0gbGVuZ3RoIGlzICR7TUFYSU1VTV9QQVRITkFNRV9MRU5HVEh9YFxuICAgICk7XG4gIH1cbiAgZm9yIChjb25zdCBpbnZhbGlkQ2hhcmFjdGVyIG9mIGRpc2FsbG93ZWRQYXRobmFtZUNoYXJhY3RlcnMpIHtcbiAgICBpZiAocGF0aG5hbWUuaW5jbHVkZXMoaW52YWxpZENoYXJhY3RlcikpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIGBwYXRobmFtZSBjYW5ub3QgY29udGFpbiBcIiR7aW52YWxpZENoYXJhY3Rlcn1cIiwgcGxlYXNlIGVuY29kZSBpdCBpZiBuZWVkZWRgXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwibWlzc2luZyBvcHRpb25zLCBzZWUgdXNhZ2VcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWNjZXNzICE9PSBcInB1YmxpY1wiKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcignYWNjZXNzIG11c3QgYmUgXCJwdWJsaWNcIicpO1xuICB9XG4gIGlmIChleHRyYUNoZWNrcykge1xuICAgIGV4dHJhQ2hlY2tzKG9wdGlvbnMpO1xuICB9XG4gIGlmIChnZXRUb2tlbikge1xuICAgIG9wdGlvbnMudG9rZW4gPSBhd2FpdCBnZXRUb2tlbihwYXRobmFtZSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvY29tcGxldGUudHNcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIHBhcnRzLCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgICAgIHVwbG9hZElkOiBvcHRpb25zLnVwbG9hZElkLFxuICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBwYXJ0c1xuICAgIH0pO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICB1cGxvYWRJZCxcbiAga2V5LFxuICBwYXRobmFtZSxcbiAgcGFydHMsXG4gIGhlYWRlcnMsXG4gIG9wdGlvbnNcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgL21wdS8ke3BhdGhuYW1lfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIFwieC1tcHUtYWN0aW9uXCI6IFwiY29tcGxldGVcIixcbiAgICAgICAgICBcIngtbXB1LXVwbG9hZC1pZFwiOiB1cGxvYWRJZCxcbiAgICAgICAgICAvLyBrZXkgY2FuIGJlIGFueSB1dGY4IGNoYXJhY3RlciBzbyB3ZSBuZWVkIHRvIGVuY29kZSBpdCBhcyBIVFRQIGhlYWRlcnMgY2FuIG9ubHkgYmUgdXMtYXNjaWlcbiAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMCNzd2VjdGlvbi0zLjIuNFxuICAgICAgICAgIFwieC1tcHUta2V5XCI6IGVuY29kZVVSSShrZXkpXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcnRzKSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZGVidWcoXCJtcHU6IGNvbXBsZXRlXCIsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnJvci5tZXNzYWdlID09PSBcIkZhaWxlZCB0byBmZXRjaFwiIHx8IGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvY3JlYXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkXG4gICAgfTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgaGVhZGVycywgb3B0aW9ucykge1xuICBkZWJ1ZyhcIm1wdTogY3JlYXRlXCIsIFwicGF0aG5hbWU6XCIsIHBhdGhuYW1lKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgL21wdS8ke3BhdGhuYW1lfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIFwieC1tcHUtYWN0aW9uXCI6IFwiY3JlYXRlXCJcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZGVidWcoXCJtcHU6IGNyZWF0ZVwiLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvdXBsb2FkLnRzXG5pbXBvcnQgYnl0ZXMgZnJvbSBcImJ5dGVzXCI7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSBcInRocm90dGxlaXRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgYm9keSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZFBhcnQoe1xuICAgICAgdXBsb2FkSWQ6IG9wdGlvbnMudXBsb2FkSWQsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBwYXJ0OiB7IGJsb2I6IGJvZHksIHBhcnROdW1iZXI6IG9wdGlvbnMucGFydE51bWJlciB9LFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZXRhZzogcmVzdWx0LmV0YWcsXG4gICAgICBwYXJ0TnVtYmVyOiBvcHRpb25zLnBhcnROdW1iZXJcbiAgICB9O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkUGFydCh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBoZWFkZXJzLFxuICBvcHRpb25zLFxuICBpbnRlcm5hbEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSxcbiAgcGFydFxufSkge1xuICB2YXIgX2EzLCBfYjIsIF9jO1xuICBjb25zdCByZXNwb25zZVByb21pc2UgPSByZXF1ZXN0QXBpKFxuICAgIGAvbXB1LyR7cGF0aG5hbWV9YCxcbiAgICB7XG4gICAgICBzaWduYWw6IGludGVybmFsQWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgIFwieC1tcHUtYWN0aW9uXCI6IFwidXBsb2FkXCIsXG4gICAgICAgIFwieC1tcHUta2V5XCI6IGVuY29kZVVSSShrZXkpLFxuICAgICAgICBcIngtbXB1LXVwbG9hZC1pZFwiOiB1cGxvYWRJZCxcbiAgICAgICAgXCJ4LW1wdS1wYXJ0LW51bWJlclwiOiBwYXJ0LnBhcnROdW1iZXIudG9TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIC8vIHdlaXJkIHRoaW5ncyBiZXR3ZWVuIHVuZGljaSB0eXBlcyBhbmQgbmF0aXZlIGZldGNoIHR5cGVzXG4gICAgICBib2R5OiBwYXJ0LmJsb2JcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxuICBpZiAoKF9hMyA9IG9wdGlvbnMuYWJvcnRTaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuYWJvcnRlZCkge1xuICAgIGhhbmRsZUFib3J0KCk7XG4gIH0gZWxzZSB7XG4gICAgKF9iMiA9IG9wdGlvbnMuYWJvcnRTaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGhhbmRsZUFib3J0KTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgKF9jID0gb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBoYW5kbGVBYm9ydCk7XG4gIHJldHVybiByZXNwb25zZTtcbn1cbnZhciBtYXhDb25jdXJyZW50VXBsb2FkcyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyA2IDogODtcbnZhciBwYXJ0U2l6ZUluQnl0ZXMgPSA4ICogMTAyNCAqIDEwMjQ7XG52YXIgbWF4Qnl0ZXNJbk1lbW9yeSA9IG1heENvbmN1cnJlbnRVcGxvYWRzICogcGFydFNpemVJbkJ5dGVzICogMjtcbmZ1bmN0aW9uIHVwbG9hZEFsbFBhcnRzKHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIHN0cmVhbSxcbiAgaGVhZGVycyxcbiAgb3B0aW9ucyxcbiAgdG90YWxUb0xvYWRcbn0pIHtcbiAgZGVidWcoXCJtcHU6IHVwbG9hZCBpbml0XCIsIFwia2V5OlwiLCBrZXkpO1xuICBjb25zdCBpbnRlcm5hbEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwYXJ0c1RvVXBsb2FkID0gW107XG4gICAgY29uc3QgY29tcGxldGVkUGFydHMgPSBbXTtcbiAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgbGV0IGFjdGl2ZVVwbG9hZHMgPSAwO1xuICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IGN1cnJlbnRQYXJ0TnVtYmVyID0gMTtcbiAgICBsZXQgcmVqZWN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudEJ5dGVzSW5NZW1vcnkgPSAwO1xuICAgIGxldCBkb25lUmVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBieXRlc1NlbnQgPSAwO1xuICAgIGxldCBhcnJheUJ1ZmZlcnMgPSBbXTtcbiAgICBsZXQgY3VycmVudFBhcnRCeXRlc1JlYWQgPSAwO1xuICAgIGxldCBvblVwbG9hZFByb2dyZXNzO1xuICAgIGNvbnN0IHRvdGFsTG9hZGVkUGVyUGFydE51bWJlciA9IHt9O1xuICAgIGlmIChvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgICAgIHZhciBfYTM7XG4gICAgICAgIGNvbnN0IGxvYWRlZCA9IE9iamVjdC52YWx1ZXModG90YWxMb2FkZWRQZXJQYXJ0TnVtYmVyKS5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgY3VyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgY3VyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHRvdGFsVG9Mb2FkIHx8IGxvYWRlZDtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHRvdGFsVG9Mb2FkID4gMCA/IE51bWJlcigoKGxvYWRlZCAvIHRvdGFsVG9Mb2FkIHx8IGxvYWRlZCkgKiAxMDApLnRvRml4ZWQoMikpIDogMDtcbiAgICAgICAgKF9hMyA9IG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKG9wdGlvbnMsIHsgbG9hZGVkLCB0b3RhbCwgcGVyY2VudGFnZSB9KTtcbiAgICAgIH0sIDE1MCk7XG4gICAgfVxuICAgIHJlYWQoKS5jYXRjaChjYW5jZWwpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCByZWFkIHN0YXJ0XCIsXG4gICAgICAgIFwiYWN0aXZlVXBsb2FkczpcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgIFwiYnl0ZXNTZW50OlwiLFxuICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICApO1xuICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICB3aGlsZSAoY3VycmVudEJ5dGVzSW5NZW1vcnkgPCBtYXhCeXRlc0luTWVtb3J5ICYmICFyZWplY3RlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGRvbmVSZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlYnVnKFwibXB1OiB1cGxvYWQgcmVhZCBjb25zdW1lZCB0aGUgd2hvbGUgc3RyZWFtXCIpO1xuICAgICAgICAgICAgaWYgKGFycmF5QnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHBhcnRzVG9VcGxvYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgcGFydE51bWJlcjogY3VycmVudFBhcnROdW1iZXIrKyxcbiAgICAgICAgICAgICAgICBibG9iOiBuZXcgQmxvYihhcnJheUJ1ZmZlcnMsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRCeXRlc0luTWVtb3J5ICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgbGV0IHZhbHVlT2Zmc2V0ID0gMDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVPZmZzZXQgPCB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdQYXJ0U2l6ZSA9IHBhcnRTaXplSW5CeXRlcyAtIGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkO1xuICAgICAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgIHZhbHVlT2Zmc2V0ICsgcmVtYWluaW5nUGFydFNpemUsXG4gICAgICAgICAgICAgIHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHZhbHVlLnNsaWNlKHZhbHVlT2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICAgICAgYXJyYXlCdWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgY3VycmVudFBhcnRCeXRlc1JlYWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlT2Zmc2V0ID0gZW5kT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkID09PSBwYXJ0U2l6ZUluQnl0ZXMpIHtcbiAgICAgICAgICAgICAgcGFydHNUb1VwbG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBjdXJyZW50UGFydE51bWJlcisrLFxuICAgICAgICAgICAgICAgIGJsb2I6IG5ldyBCbG9iKGFycmF5QnVmZmVycywge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhcnJheUJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgICAgY3VycmVudFBhcnRCeXRlc1JlYWQgPSAwO1xuICAgICAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FuY2VsKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgcmVhZCBlbmRcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNlbmRQYXJ0KHBhcnQpIHtcbiAgICAgIGFjdGl2ZVVwbG9hZHMrKztcbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHNlbmQgcGFydCBzdGFydFwiLFxuICAgICAgICBcInBhcnROdW1iZXI6XCIsXG4gICAgICAgIHBhcnQucGFydE51bWJlcixcbiAgICAgICAgXCJzaXplOlwiLFxuICAgICAgICBwYXJ0LmJsb2Iuc2l6ZSxcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1cGxvYWRQcm9ncmVzc0ZvclBhcnQgPSBvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICB0b3RhbExvYWRlZFBlclBhcnROdW1iZXJbcGFydC5wYXJ0TnVtYmVyXSA9IGV2ZW50LmxvYWRlZDtcbiAgICAgICAgICBpZiAob25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgY29tcGxldGVkUGFydCA9IGF3YWl0IHVwbG9hZFBhcnQoe1xuICAgICAgICAgIHVwbG9hZElkLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiB1cGxvYWRQcm9ncmVzc0ZvclBhcnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludGVybmFsQWJvcnRDb250cm9sbGVyLFxuICAgICAgICAgIHBhcnRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgIFwibXB1OiB1cGxvYWQgc2VuZCBwYXJ0IGVuZFwiLFxuICAgICAgICAgIFwicGFydE51bWJlcjpcIixcbiAgICAgICAgICBwYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgICAgXCJhY3RpdmVVcGxvYWRzXCIsXG4gICAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICAgIFwiYnl0ZXNTZW50OlwiLFxuICAgICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBsZXRlZFBhcnRzLnB1c2goe1xuICAgICAgICAgIHBhcnROdW1iZXI6IHBhcnQucGFydE51bWJlcixcbiAgICAgICAgICBldGFnOiBjb21wbGV0ZWRQYXJ0LmV0YWdcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRCeXRlc0luTWVtb3J5IC09IHBhcnQuYmxvYi5zaXplO1xuICAgICAgICBhY3RpdmVVcGxvYWRzLS07XG4gICAgICAgIGJ5dGVzU2VudCArPSBwYXJ0LmJsb2Iuc2l6ZTtcbiAgICAgICAgaWYgKHBhcnRzVG9VcGxvYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNlbmRQYXJ0cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb25lUmVhZGluZykge1xuICAgICAgICAgIGlmIChhY3RpdmVVcGxvYWRzID09PSAwKSB7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIHJlc29sdmUoY29tcGxldGVkUGFydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWFkaW5nKSB7XG4gICAgICAgICAgcmVhZCgpLmNhdGNoKGNhbmNlbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhbmNlbChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlbmRQYXJ0cygpIHtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJzZW5kIHBhcnRzXCIsXG4gICAgICAgIFwiYWN0aXZlVXBsb2Fkc1wiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcInBhcnRzVG9VcGxvYWRcIixcbiAgICAgICAgcGFydHNUb1VwbG9hZC5sZW5ndGhcbiAgICAgICk7XG4gICAgICB3aGlsZSAoYWN0aXZlVXBsb2FkcyA8IG1heENvbmN1cnJlbnRVcGxvYWRzICYmIHBhcnRzVG9VcGxvYWQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwYXJ0VG9TZW5kID0gcGFydHNUb1VwbG9hZC5zaGlmdCgpO1xuICAgICAgICBpZiAocGFydFRvU2VuZCkge1xuICAgICAgICAgIHZvaWQgc2VuZFBhcnQocGFydFRvU2VuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsKGVycm9yKSB7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnJvci5tZXNzYWdlID09PSBcIkZhaWxlZCB0byBmZXRjaFwiIHx8IGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpKSB7XG4gICAgICAgIHJlamVjdChuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9wdXQudHNcbmltcG9ydCB0aHJvdHRsZTIgZnJvbSBcInRocm90dGxlaXRcIjtcblxuLy8gc3JjL211bHRpcGFydC91bmNvbnRyb2xsZWQudHNcbmFzeW5jIGZ1bmN0aW9uIHVuY29udHJvbGxlZE11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICBkZWJ1ZyhcIm1wdTogaW5pdFwiLCBcInBhdGhuYW1lOlwiLCBwYXRobmFtZSwgXCJoZWFkZXJzOlwiLCBoZWFkZXJzKTtcbiAgY29uc3Qgb3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzID0ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgb25VcGxvYWRQcm9ncmVzczogdm9pZCAwXG4gIH07XG4gIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgIHBhdGhuYW1lLFxuICAgIGhlYWRlcnMsXG4gICAgb3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzXG4gICk7XG4gIGNvbnN0IHRvdGFsVG9Mb2FkID0gY29tcHV0ZUJvZHlMZW5ndGgoYm9keSk7XG4gIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRvUmVhZGFibGVTdHJlYW0oYm9keSk7XG4gIGNvbnN0IHBhcnRzID0gYXdhaXQgdXBsb2FkQWxsUGFydHMoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBzdHJlYW0sXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zLFxuICAgIHRvdGFsVG9Mb2FkXG4gIH0pO1xuICBjb25zdCBibG9iID0gYXdhaXQgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJ0cyxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNXaXRob3V0T25VcGxvYWRQcm9ncmVzc1xuICB9KTtcbiAgcmV0dXJuIGJsb2I7XG59XG5cbi8vIHNyYy9wdXQudHNcbmZ1bmN0aW9uIGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zLFxuICBnZXRUb2tlbixcbiAgZXh0cmFDaGVja3Ncbn0pIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHB1dChwYXRobmFtZSwgYm9keSwgb3B0aW9uc0lucHV0KSB7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiYm9keSBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm11bHRpcGFydCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHVuY29udHJvbGxlZE11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG9uVXBsb2FkUHJvZ3Jlc3MgPSBvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MgPyB0aHJvdHRsZTIob3B0aW9ucy5vblVwbG9hZFByb2dyZXNzLCAxMDApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICAgIGAvJHtwYXRobmFtZX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgb25VcGxvYWRQcm9ncmVzc1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgZG93bmxvYWRVcmw6IHJlc3BvbnNlLmRvd25sb2FkVXJsLFxuICAgICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lLFxuICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uOiByZXNwb25zZS5jb250ZW50RGlzcG9zaXRpb25cbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NyZWF0ZS11cGxvYWRlci50c1xuZnVuY3Rpb24gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgYXN5bmMgdXBsb2FkUGFydChwYXJ0TnVtYmVyLCBib2R5KSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHBhcnQ6IHsgcGFydE51bWJlciwgYmxvYjogYm9keSB9LFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBldGFnOiByZXN1bHQuZXRhZyxcbiAgICAgICAgICBwYXJ0TnVtYmVyXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYXN5bmMgY29tcGxldGUocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgICAgICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAgICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgcGFydHMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy9jcmVhdGUtZm9sZGVyLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVGb2xkZXIocGF0aG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwYXRoID0gcGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpID8gcGF0aG5hbWUgOiBgJHtwYXRobmFtZX0vYDtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5hZGRSYW5kb21TdWZmaXhdID0gXCIwXCI7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICBgLyR7cGF0aH1gLFxuICAgIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBwYXRobmFtZTogcmVzcG9uc2UucGF0aG5hbWVcbiAgfTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52LFxuICBCbG9iRXJyb3IsXG4gIGdldERvd25sb2FkVXJsLFxuICBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzLFxuICBNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSCxcbiAgQmxvYkFjY2Vzc0Vycm9yLFxuICBCbG9iQ29udGVudFR5cGVOb3RBbGxvd2VkRXJyb3IsXG4gIEJsb2JQYXRobmFtZU1pc21hdGNoRXJyb3IsXG4gIEJsb2JDbGllbnRUb2tlbkV4cGlyZWRFcnJvcixcbiAgQmxvYkZpbGVUb29MYXJnZUVycm9yLFxuICBCbG9iU3RvcmVOb3RGb3VuZEVycm9yLFxuICBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvcixcbiAgQmxvYlVua25vd25FcnJvcixcbiAgQmxvYk5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlLFxuICBCbG9iU2VydmljZVJhdGVMaW1pdGVkLFxuICBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgcmVxdWVzdEFwaSxcbiAgY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlVXBsb2FkUGFydE1ldGhvZCxcbiAgY3JlYXRlUHV0TWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCxcbiAgY3JlYXRlRm9sZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstS042V1Q1R1AuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/blob/dist/chunk-KN6WT5GP.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@vercel/blob/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobAccessError),\n/* harmony export */   BlobClientTokenExpiredError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobClientTokenExpiredError),\n/* harmony export */   BlobContentTypeNotAllowedError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobContentTypeNotAllowedError),\n/* harmony export */   BlobError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError),\n/* harmony export */   BlobFileTooLargeError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobFileTooLargeError),\n/* harmony export */   BlobNotFoundError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobNotFoundError),\n/* harmony export */   BlobPathnameMismatchError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobPathnameMismatchError),\n/* harmony export */   BlobRequestAbortedError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobUnknownError),\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   copy: () => (/* binding */ copy),\n/* harmony export */   createFolder: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createFolder),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   del: () => (/* binding */ del),\n/* harmony export */   getDownloadUrl: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.getDownloadUrl),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-KN6WT5GP.js */ \"(rsc)/./node_modules/@vercel/blob/dist/chunk-KN6WT5GP.js\");\n\n\n// src/del.ts\nasync function del(url, options) {\n  await (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    \"/delete\",\n    {\n      method: \"POST\",\n      headers: { \"content-type\": \"application/json\" },\n      body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n}\n\n// src/head.ts\nasync function head(url, options) {\n  const searchParams = new URLSearchParams({ url });\n  const response = await (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `?${searchParams.toString()}`,\n    // HEAD can't have body as a response, so we use GET\n    {\n      method: \"GET\",\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    size: response.size,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n    cacheControl: response.cacheControl,\n    uploadedAt: new Date(response.uploadedAt)\n  };\n}\n\n// src/list.ts\nasync function list(options) {\n  var _a;\n  const searchParams = new URLSearchParams();\n  if (options == null ? void 0 : options.limit) {\n    searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (options == null ? void 0 : options.prefix) {\n    searchParams.set(\"prefix\", options.prefix);\n  }\n  if (options == null ? void 0 : options.cursor) {\n    searchParams.set(\"cursor\", options.cursor);\n  }\n  if (options == null ? void 0 : options.mode) {\n    searchParams.set(\"mode\", options.mode);\n  }\n  const response = await (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `?${searchParams.toString()}`,\n    {\n      method: \"GET\",\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n  if ((options == null ? void 0 : options.mode) === \"folded\") {\n    return {\n      folders: (_a = response.folders) != null ? _a : [],\n      cursor: response.cursor,\n      hasMore: response.hasMore,\n      blobs: response.blobs.map(mapBlobResult)\n    };\n  }\n  return {\n    cursor: response.cursor,\n    hasMore: response.hasMore,\n    blobs: response.blobs.map(mapBlobResult)\n  };\n}\nfunction mapBlobResult(blobResult) {\n  return {\n    url: blobResult.url,\n    downloadUrl: blobResult.downloadUrl,\n    pathname: blobResult.pathname,\n    size: blobResult.size,\n    uploadedAt: new Date(blobResult.uploadedAt)\n  };\n}\n\n// src/copy.ts\nasync function copy(fromUrl, toPathname, options) {\n  if (!options) {\n    throw new _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError('access must be \"public\"');\n  }\n  if (toPathname.length > _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.MAXIMUM_PATHNAME_LENGTH) {\n    throw new _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\n      `pathname is too long, maximum length is ${_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.MAXIMUM_PATHNAME_LENGTH}`\n    );\n  }\n  for (const invalidCharacter of _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.disallowedPathnameCharacters) {\n    if (toPathname.includes(invalidCharacter)) {\n      throw new _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`\n      );\n    }\n  }\n  const headers = {};\n  if (options.addRandomSuffix !== void 0) {\n    headers[\"x-add-random-suffix\"] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (options.contentType) {\n    headers[\"x-content-type\"] = options.contentType;\n  }\n  if (options.cacheControlMaxAge !== void 0) {\n    headers[\"x-cache-control-max-age\"] = options.cacheControlMaxAge.toString();\n  }\n  const response = await (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `/${toPathname}?fromUrl=${fromUrl}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition\n  };\n}\n\n// src/index.ts\nvar put = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createPutMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar createMultipartUpload = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploadMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar createMultipartUploader = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploaderMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar uploadPart = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createUploadPartMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar completeMultipartUpload = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createCompleteMultipartUploadMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCNkI7O0FBRTdCO0FBQ0E7QUFDQSxRQUFRLDhEQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQsNkJBQTZCLHdDQUF3QztBQUNyRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xELHlCQUF5Qiw4REFBVTtBQUNuQyxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4REFBVTtBQUNuQyxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBLDBCQUEwQix1RUFBdUI7QUFDakQsY0FBYyx5REFBUztBQUN2QixpREFBaUQsdUVBQXVCLENBQUM7QUFDekU7QUFDQTtBQUNBLGlDQUFpQyw0RUFBNEI7QUFDN0Q7QUFDQSxnQkFBZ0IseURBQVM7QUFDekIsb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4REFBVTtBQUNuQyxRQUFRLFdBQVcsV0FBVyxRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxtRUFBZTtBQUN6QjtBQUNBLENBQUM7QUFDRCw0QkFBNEIscUZBQWlDO0FBQzdEO0FBQ0EsQ0FBQztBQUNELDhCQUE4Qix1RkFBbUM7QUFDakU7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLDBFQUFzQjtBQUN2QztBQUNBLENBQUM7QUFDRCw4QkFBOEIsdUZBQW1DO0FBQ2pFO0FBQ0EsQ0FBQztBQTBCQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2FkYWktcmFjb21wLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L2luZGV4LmpzP2NkZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmxvYkFjY2Vzc0Vycm9yLFxuICBCbG9iQ2xpZW50VG9rZW5FeHBpcmVkRXJyb3IsXG4gIEJsb2JDb250ZW50VHlwZU5vdEFsbG93ZWRFcnJvcixcbiAgQmxvYkVycm9yLFxuICBCbG9iRmlsZVRvb0xhcmdlRXJyb3IsXG4gIEJsb2JOb3RGb3VuZEVycm9yLFxuICBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yLFxuICBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUsXG4gIEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQsXG4gIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yLFxuICBCbG9iVW5rbm93bkVycm9yLFxuICBNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSCxcbiAgY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QsXG4gIGNyZWF0ZUZvbGRlcixcbiAgY3JlYXRlUHV0TWV0aG9kLFxuICBjcmVhdGVVcGxvYWRQYXJ0TWV0aG9kLFxuICBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzLFxuICBnZXREb3dubG9hZFVybCxcbiAgcmVxdWVzdEFwaVxufSBmcm9tIFwiLi9jaHVuay1LTjZXVDVHUC5qc1wiO1xuXG4vLyBzcmMvZGVsLnRzXG5hc3luYyBmdW5jdGlvbiBkZWwodXJsLCBvcHRpb25zKSB7XG4gIGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgXCIvZGVsZXRlXCIsXG4gICAge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXJsczogQXJyYXkuaXNBcnJheSh1cmwpID8gdXJsIDogW3VybF0gfSksXG4gICAgICBzaWduYWw6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cblxuLy8gc3JjL2hlYWQudHNcbmFzeW5jIGZ1bmN0aW9uIGhlYWQodXJsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyB1cmwgfSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICBgPyR7c2VhcmNoUGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICAvLyBIRUFEIGNhbid0IGhhdmUgYm9keSBhcyBhIHJlc3BvbnNlLCBzbyB3ZSB1c2UgR0VUXG4gICAge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgc2lnbmFsOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIHJldHVybiB7XG4gICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgZG93bmxvYWRVcmw6IHJlc3BvbnNlLmRvd25sb2FkVXJsLFxuICAgIHBhdGhuYW1lOiByZXNwb25zZS5wYXRobmFtZSxcbiAgICBzaXplOiByZXNwb25zZS5zaXplLFxuICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSxcbiAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICBjYWNoZUNvbnRyb2w6IHJlc3BvbnNlLmNhY2hlQ29udHJvbCxcbiAgICB1cGxvYWRlZEF0OiBuZXcgRGF0ZShyZXNwb25zZS51cGxvYWRlZEF0KVxuICB9O1xufVxuXG4vLyBzcmMvbGlzdC50c1xuYXN5bmMgZnVuY3Rpb24gbGlzdChvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5saW1pdCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJsaW1pdFwiLCBvcHRpb25zLmxpbWl0LnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnByZWZpeCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJwcmVmaXhcIiwgb3B0aW9ucy5wcmVmaXgpO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmN1cnNvcikge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJjdXJzb3JcIiwgb3B0aW9ucy5jdXJzb3IpO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwibW9kZVwiLCBvcHRpb25zLm1vZGUpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICBgPyR7c2VhcmNoUGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBzaWduYWw6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgaWYgKChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpID09PSBcImZvbGRlZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbGRlcnM6IChfYSA9IHJlc3BvbnNlLmZvbGRlcnMpICE9IG51bGwgPyBfYSA6IFtdLFxuICAgICAgY3Vyc29yOiByZXNwb25zZS5jdXJzb3IsXG4gICAgICBoYXNNb3JlOiByZXNwb25zZS5oYXNNb3JlLFxuICAgICAgYmxvYnM6IHJlc3BvbnNlLmJsb2JzLm1hcChtYXBCbG9iUmVzdWx0KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjdXJzb3I6IHJlc3BvbnNlLmN1cnNvcixcbiAgICBoYXNNb3JlOiByZXNwb25zZS5oYXNNb3JlLFxuICAgIGJsb2JzOiByZXNwb25zZS5ibG9icy5tYXAobWFwQmxvYlJlc3VsdClcbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcEJsb2JSZXN1bHQoYmxvYlJlc3VsdCkge1xuICByZXR1cm4ge1xuICAgIHVybDogYmxvYlJlc3VsdC51cmwsXG4gICAgZG93bmxvYWRVcmw6IGJsb2JSZXN1bHQuZG93bmxvYWRVcmwsXG4gICAgcGF0aG5hbWU6IGJsb2JSZXN1bHQucGF0aG5hbWUsXG4gICAgc2l6ZTogYmxvYlJlc3VsdC5zaXplLFxuICAgIHVwbG9hZGVkQXQ6IG5ldyBEYXRlKGJsb2JSZXN1bHQudXBsb2FkZWRBdClcbiAgfTtcbn1cblxuLy8gc3JjL2NvcHkudHNcbmFzeW5jIGZ1bmN0aW9uIGNvcHkoZnJvbVVybCwgdG9QYXRobmFtZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwibWlzc2luZyBvcHRpb25zLCBzZWUgdXNhZ2VcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWNjZXNzICE9PSBcInB1YmxpY1wiKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcignYWNjZXNzIG11c3QgYmUgXCJwdWJsaWNcIicpO1xuICB9XG4gIGlmICh0b1BhdGhuYW1lLmxlbmd0aCA+IE1BWElNVU1fUEFUSE5BTUVfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgIGBwYXRobmFtZSBpcyB0b28gbG9uZywgbWF4aW11bSBsZW5ndGggaXMgJHtNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSH1gXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGludmFsaWRDaGFyYWN0ZXIgb2YgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycykge1xuICAgIGlmICh0b1BhdGhuYW1lLmluY2x1ZGVzKGludmFsaWRDaGFyYWN0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBgcGF0aG5hbWUgY2Fubm90IGNvbnRhaW4gXCIke2ludmFsaWRDaGFyYWN0ZXJ9XCIsIHBsZWFzZSBlbmNvZGUgaXQgaWYgbmVlZGVkYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAob3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbXCJ4LWFkZC1yYW5kb20tc3VmZml4XCJdID0gb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggPyBcIjFcIiA6IFwiMFwiO1xuICB9XG4gIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgaGVhZGVyc1tcIngtY29udGVudC10eXBlXCJdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgfVxuICBpZiAob3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbXCJ4LWNhY2hlLWNvbnRyb2wtbWF4LWFnZVwiXSA9IG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGAvJHt0b1BhdGhuYW1lfT9mcm9tVXJsPSR7ZnJvbVVybH1gLFxuICAgIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lLFxuICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSxcbiAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvblxuICB9O1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBwdXQgPSBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xudmFyIGNyZWF0ZU11bHRpcGFydFVwbG9hZCA9IGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG52YXIgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXIgPSBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG52YXIgdXBsb2FkUGFydCA9IGNyZWF0ZVVwbG9hZFBhcnRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xudmFyIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkID0gY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xuZXhwb3J0IHtcbiAgQmxvYkFjY2Vzc0Vycm9yLFxuICBCbG9iQ2xpZW50VG9rZW5FeHBpcmVkRXJyb3IsXG4gIEJsb2JDb250ZW50VHlwZU5vdEFsbG93ZWRFcnJvcixcbiAgQmxvYkVycm9yLFxuICBCbG9iRmlsZVRvb0xhcmdlRXJyb3IsXG4gIEJsb2JOb3RGb3VuZEVycm9yLFxuICBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yLFxuICBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUsXG4gIEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQsXG4gIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yLFxuICBCbG9iVW5rbm93bkVycm9yLFxuICBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCxcbiAgY29weSxcbiAgY3JlYXRlRm9sZGVyLFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWQsXG4gIGNyZWF0ZU11bHRpcGFydFVwbG9hZGVyLFxuICBkZWwsXG4gIGdldERvd25sb2FkVXJsLFxuICBoZWFkLFxuICBsaXN0LFxuICBwdXQsXG4gIHVwbG9hZFBhcnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/blob/dist/index.js\n");

/***/ })

};
;